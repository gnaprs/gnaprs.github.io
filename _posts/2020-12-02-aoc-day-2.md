---
layout: post
title: Advent of Code 2020 (Day 2)
date: 2020-12-02
excerpt: "Throwback to some logic gates."
tag: 
- coding
- fun
comments: false
---

# Day 2
<a href="https://adventofcode.com/2020/day/2"><b>Password Philosophy</b></a>

Wow, Santa sure likes to travel stylishly. Remind me to buy a toboggan for the next time I want to sled my way to the airport. But of course, the toboggan rental shop is having some trouble too - this time with their corrupted password database.

To try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set.
~~~
    1-3 a: abcde
    1-3 b: cdefg
    1-3 b: cdefg
~~~

First, we do a little bit of string manipulation to extract the necessary information from our given dataset.

```python
import pandas as pd
import numpy as np

# import from given input
df1 = pd.read_csv("input.txt", header=None)
arr=np.ndarray.flatten(df1.values)

df = pd.DataFrame(arr,columns=['password'])

# formatting strings
df[['num','letter','password']] = df['password'].str.split(' ',expand=True)
df[['num1','num2']] = df['num'].str.split('-',expand=True)
df['letter'] = df['letter'].map(lambda x: x.strip(':'))

# as an example, show top 3 formatted entries
df.head(3)
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>password</th>
      <th>num</th>
      <th>letter</th>
      <th>num1</th>
      <th>num2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>qllllqllklhlvtl</td>
      <td>8-11</td>
      <td>l</td>
      <td>8</td>
      <td>11</td>
    </tr>
    <tr>
      <th>1</th>
      <td>wmmmmmttm</td>
      <td>1-3</td>
      <td>m</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>pgppp</td>
      <td>2-4</td>
      <td>p</td>
      <td>2</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>

## Part 1
*Their password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen.* 
The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.

<center>Tl;dr Frequency of the specified character in the password needs to be within the specified range!</center>
{: .notice}

Seems pretty simple - we can use the count() method to count the frequency of the letter in the password, and check if its within our desired range.

```python

def isValidPassword_p1(password, num1, num2, letter):
    # counting frequency of letter in password
    freq=password.count(letter)
    
    if(freq >= int(num1) and freq <= int(num2)):
        # letter freq in specified range
        return(True) 
    else:
        # letter freq not in specified range
        return(False)

df['valid_p1']=df.apply(lambda x: isValidPassword_p1(x['password'], x['num1'], x['num2'], x['letter']), axis=1)
df['valid_p1'].value_counts()
```




    False    584
    True     416
    Name: valid_p1, dtype: int64

Ans: `416`

## Part 2
*The shopkeeper suddenly realizes that he just accidentally explained the password policy rules from his old job at the sled rental place down the street! The Official Toboggan Corporate Policy actually works a little differently.* **I'm a little worried about the cybersecurity of this toboggan shop ngl.**
<center>Tl;dr Letters at the positions of the two numbers should match the given character only <b>once</b>.</center>
{: .notice}

Alrighty! This one is a bit more of a challenge. I'll take the opportunity to explain a little bit about logic, and logic gates! In this problem, we want only **one** of the letters to match with our specified character. Placed into something called a truth table (where 1: True, 0: False), we have this:

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-pb0m{border-color:inherit;text-align:center;vertical-align:bottom}
.tg .tg-za14{border-color:inherit;text-align:left;vertical-align:bottom}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-pb0m" colspan="2">Input</th>
    <th class="tg-za14">Output</th>
    <th class="tg-0pky"></th>
    <th class="tg-0pky"></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-za14">Left</td>
    <td class="tg-za14">Right</td>
    <td class="tg-za14">XOR</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-za14">0</td>
    <td class="tg-za14">0</td>
    <td class="tg-za14">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-za14">0</td>
    <td class="tg-za14">1</td>
    <td class="tg-za14">1</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-za14">1</td>
    <td class="tg-za14">0</td>
    <td class="tg-za14">1</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-za14">1</td>
    <td class="tg-za14">1</td>
    <td class="tg-za14">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
</tbody>
</table>

It turns out that our little brute force method from before wouldn't be quite as efficient in finding a triplet. Blindly running through every single combination for a triplet with **three** nested for loops is a \\(O(n^3)\\) solution - still alright for our little 200 element sized input, but not great if the Elves suddenly unearthed 5 more piles of accounting tables.

So, a little bit of thinking later (and some googling, not gonna lie), I chanced upon the <a href="https://www.geeksforgeeks.org/two-pointers-technique/">Two Pointer Technique</a>. The concept is simple: Given a sorted array `A` (sorted in ascending order), having `N` integers, find if there exists any pair of elements (`A[i]`, `A[j]`) such that their sum is equal to `X`. This is a lot smarter, because by finding smart pairs (i.e. comparing the sum we're getting to what we want), we can reduce the time complexity of our solution down to \\(O(n^2)+O(n \log n)\approx O(n^2)\\). Yay for optimization!

The algorithm is then pretty simple:
1. First, we hold out one of the triplets, finding our desired sum of the pair.
2. We use the two pointer technique to efficiently determine whether the sum can be reached.
3. If not, skip and move on to hold out the next element of the array.
4. Repeat till our triplet is golden :)

```python
import numpy as np

arr1=np.ndarray.flatten(arr)
arr1.sort()
arr1
```

    array([  24,  465,  539,  812,  896, 1124, 1149, 1207, 1215, 1217, 1222,
           1224, 1225, 1232, 1234, 1237, 1240, 1241, 1252, 1270, 1271, 1279,
           1280, 1284, 1299, 1301, 1304, 1317, 1329, 1330, 1331, 1338, 1343,
           1360, 1365, 1369, 1371, 1372, 1376, 1379, 1381, 1383, 1384, 1386,
           1388, 1389, 1394, 1395, 1397, 1400, 1410, 1417, 1419, 1422, 1427,
           1429, 1434, 1435, 1441, 1442, 1443, 1453, 1457, 1458, 1462, 1469,
           1470, 1473, 1484, 1487, 1490, 1494, 1502, 1505, 1510, 1515, 1524,
           1528, 1536, 1539, 1541, 1544, 1546, 1548, 1551, 1554, 1562, 1566,
           1572, 1582, 1585, 1586, 1589, 1592, 1593, 1597, 1602, 1610, 1615,
           1616, 1619, 1625, 1626, 1629, 1630, 1631, 1632, 1637, 1638, 1647,
           1652, 1658, 1675, 1676, 1688, 1691, 1692, 1697, 1700, 1705, 1707,
           1710, 1711, 1712, 1713, 1720, 1721, 1723, 1736, 1737, 1739, 1741,
           1744, 1745, 1748, 1751, 1752, 1753, 1754, 1758, 1769, 1778, 1780,
           1788, 1792, 1794, 1795, 1800, 1804, 1805, 1815, 1817, 1821, 1823,
           1825, 1829, 1836, 1856, 1857, 1868, 1883, 1884, 1885, 1888, 1892,
           1896, 1902, 1908, 1911, 1915, 1922, 1932, 1933, 1934, 1941, 1948,
           1950, 1955, 1956, 1958, 1963, 1966, 1968, 1974, 1975, 1976, 1977,
           1979, 1980, 1982, 1983, 1988, 1994, 2001, 2003, 2005, 2006, 2008,
           2009, 2010], dtype=int64)


```python
def getTriplet(arr, sum): 
    n = len(arr)
    
    arr.sort() # sort from lowest to highest, fix first element
    
    for i in range(0, n-2): 
        l = i + 1 # left is one after locked value
          
        r = n-1 # right is end of array
        while (l < r): 
            if( arr[i] + arr[l] + arr[r] == sum): 
                print(arr[i], arr[l], arr[r])
                return arr[i], arr[l], arr[r]

            # if less than sum, move to a larger number (left move)
            elif (arr[i] + arr[l] + arr[r] < sum): 
                l += 1
            # if more than sum, move to a smaller number (right move)
            else: # A[i] + A[l] + A[r] > sum 
                r -= 1
  
    # rip no triplet shrugs
    return 0,0,0

ans1,ans2,ans3=getTriplet(arr1,2020)
print(ans1*ans2*ans3)
```

    24 539 1457
    18847752

And there we have it - our golden triplet, `24 539 1457`! Ans: `18847752`

> Thoughts after day 1: given that it's the first day, the problems weren't too difficult - nonetheless, it's a good start to the month, and my problem solving engines have been revved up. Onwards we go!
